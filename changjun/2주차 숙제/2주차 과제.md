# Linked List (연결 리스트)

## 연결 리스트란?
- 배열과 달리 원소를 저장할 때 다음 원소의 위치를 포함시켜 저장하는 방식
```c++
//간단한 연결 리스트
struct NODE {
    struct NODE *prev, *next;
    int data;
};
```

<br/>

## 연결 리스트의 성질
- k번째 원소를 확인 / 변경하기 위해 O(k)가 필요함
  > k 번째 원소를 찾기 위해 앞의 원소를 모두 찾아 봐야 하기 때문
- 임의의 위치에 원소를 추가 / 임의 위치의 원소 제거는 O(1)

- 원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움

<br/>

## 연결 리스트의 종류
- 단일 연결 리스트
  - 각 원소가 다음 원소의 주소를 가지고 있음 
- 이중 연결 리스트
  - 각 원소가 이전 원소와 다음 원소의 주소를 모두 가지고 있음
  - 단일 연결 리스트에 비해 메모리를 더 소모함
  - STL에서의 list가 이중 연결 리스트
- 원형 연결 리스트
  - 마지막 원소가 처음 원소의 주소를 가지고 있음
  - 단일 연결 리스트, 이중 연결 리스트 모두 가능

<br/>

## 배열과 연결 리스트의 차이
- 공통점
  - 선형 자료구조
- 차이점
  - k번째의 원소의 접근은 배열은 O(1), 연결 리스트는 O(k)
  - 임의의 원소를 추가 / 제거는 배열은 O(N), 연결 리스트는 O(1)
  - 메모리 상에서 배열은 연속적, 연결 리스트는 불연속적
  - 배열은 추가 공간 필요 X, 연결 리스트는 주소값을 필요로 하므로 바이트에 비례하는 추가 공간이 필요
> ## **Tip**  
> ### 알고리즘 문제를 풀때는 보통 배열이 유리  
> 리스트의 입력은 추가 과정마다 메모리의 할당이 일어나고 삭제에서는 메모리의 해제가 일어나므로, 메모리 공간의 범위가 주어지는 알고리즘 문제에서 배열 선언을 최대치로 한다면 훨씬 더 편리하고 빠른 속도를 보이기 때문

<br/>

## 간단한 연결 리스트 구현
```c++
const int MX = 100000;
int data[MX], pre[MX], nxt[MX];
int unused = 1;

fill (pre, pre+MX, -1);
fill (pre, nxt+MX, -1);
```
- 배열을 만들어 원소의 주소, 값들을 저장함
- 사용하지 않은 원소의 주소는 -1을 통해 나타냄
- 실무에서는 매우 비효율적이므로 차라리 STL의 list를 활용

<br/>

## STL list
- list 헤더 파일 사용
- list\<int> 등의 형식으로 사용 가능
- push_front(n), push_back(n), insert(p, n), erase(p, n) 등 사용 가능
- 리스트의 위치 값을 가리킬 때는 보통 iterator를 사용
- iterator는 list\<int>::iterator로 선언하거나 auto로 선언 가능
---

# Stack (스택)

## 스택이란?
- 한쪽에서만 원소를 넣거나 뺄 수 있는 자료구조 (FILO)

<br/>

## 스택의 성질
- 원소의 추가 / 제거 O(1)
- 제일 상단의 원소 확인 O(1)
- 상단이 아닌 나머지 원소의 확인 / 변경 불가능
- 배열처럼 원소를 추가할 때 나머지 원소를 이동할 필요 없음
> ## **Tip**  
> ### 스택의 사용 용도 
> 1. 자료의 순서를 뒤집는데 유용
> 2. 재귀 함수 제거에 유용
> 3. 컴퓨터 연산 순서에 맞게 자료 재정리에 유용

<br/>

## 간단한 스택 구현
```c++
const int MX = 100000;
int data[MX];
int pos = 0;
```
- 배열을 만들어 원소의 값들을 저장
- 원래의 스택은 상단이 아닌 나머지 원소의 확인이 불가능 하지만 배열로 만든 스택은 확인이 가능
- 배열 이외에도 연결 리스트 등으로도 구현 가능

<br/>

## STL list
- stack 헤더 파일 사용
- stack\<int> 등의 형식으로 사용 가능
- push(n), pop(n), top(), empty(), size() 등 사용 가능