[배열의 성질]

1. O(1)에 k번째 원소를 확인/변경 가능

2. 추가적으로 소모되는 메모리의 양(=overhead)가 거의 없음

3. Cache hit rate가 높음 (뭔지 찾아보기)

4. 메모리상에 연속한 구간을 잡아야 해서 할당에 제약에 걸림


[시간복잡도]
1. 임의 위치 변경 : 자명하게 O(1) 
원소를 끝에 추가 : 끝자리에 숫자 쓰고 길이 증가 O(1)
끝자리를 줄이는것 : 줄이면 되니 O(1)

2.임의의 위치에 "추가" : 추가하고 뒤의 배열을 밀어야한다.
평균적으로 N/2개를 미뤄야 하니 O(N)이라 표현

3.임의의 위치에 "제거" : 제거하고 뒤의 배열을 댕겨야 한다.
마찬가지로 평균적으로 N/2개를 댕겨야 하니 O(N)이라 표현


[소스코드 연습용]
void insert(int idx, int num, int arr[], int& len) {
	len++;			//일단 배열의 길이를 늘린다.
	for (int i = len; idx < i; i--)	//맨 끝항에서부터 idx보다 뒤에 있는 항까지
		arr[i] = arr[i - 1];	//오른쪽 항에서 왼쪽 항을 당겨온다.
	arr[idx] = num;		//idx번째 칸을 num으로 채운다. 
}

void erase(int idx, int arr[], int& len) {
	for (int i = idx; i < len; i++) 	//idx항부터 마지막 항이전까지
		arr[i] = arr[i + 1];	//왼쪽항에서 오른쪽 항을 당겨온다.
	len--;			//배열의 길이를 줄인다.
}



***당기고 미는 과정의 방향을 잘 정하면 추가적인 메모리를 발생시키지 않고 할 수 있다.***


[초기화 꿀팁]

cstring 헤더에 있는 memset함수
실수의 여지가 많고 2차원 배열에서 잘못되는 경우 빈번 memset -> 비추천

for문 -> 실수 여지 적지 적고 무난함
대신 코드가 좀 투박함

algorithm 헤더의 fill 함수를 이용하는것
실수의 여지도 적고 코드도 짧아서 익숙해진다면 가장 추천한다.



***배열은 데이터를 자주 바꾸지 않고 그냥 쌓아두고 싶을때 잘 활용할 수 있다. ****



문제 풀이 전략
1. 바로 생각나는대로 풀어보기
2. 시간복잡도를 고려해서 수정해보기



