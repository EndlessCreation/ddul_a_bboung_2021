# [연결리스트]  

```c++
typedef struct Node
{
	struct Node *next;
	int data;
};
```
위와 같이
이전 원소가 다음 원소를 기억하는 꼬리물기의 형태   


*** 

### [연결리스트의 성질]  
* k번째 원소를 확인/변경하기 위해 O(k)가 필요  
  
* 임의의 위치에 원소 추가/제거는 O(1)
    
* 원소들이 메모리상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움  


*** 

### [연결리스트의 종류]
* 단일 연결 리스트
	* 다음 원소의 주소를 갖고 있는 방식  

* 이중 연결 리스트  
	* 이전 원소와 다음 원소의 정보를 모두 갖고 있는 방식  

* 원형 연결 리스트
	* 원소의 끝과 처음이 연결되어 순환이 가능한 방식  


*** 

### [배열 vs 연결리스트]  

항목		|배열		|연결리스트
-----------------------|-----------------|-------------------------
k번째 원소에 접근	|O(1)		|O(N)
임의의 원소 추가/제거	|O(N)		|O(1)
메모리상의 배치	|연속		|불연속
추가 필요 공간	|-		|O(N)


*** 

### [연결리스트 원소의 생성]

```c++
Node *dummy = (Node*)malloc(sizeof(Node));	//첫번째 원소를 가리킬 원소
Node *newNode = NULL;				//새로 만들어질 원소
Node *cur = dummy;				//dummy에서 시작하여 연산이 수행될 위치를 나타내는 원소
	
newNode = new Node();
newNode->data = i;	
newNode->next = NULL;				//새로운 원소를 생성

cur->next = newNode;				//현재 원소와 생성된 원소를 연결

if (isCircularLinkedList)
	newNode->next = dummy->next;		//마지막 원소와 첫번째 원소를 연결하면 원형 연결 리스트 완성

cur = newNode;					//현재 노드를 새로 만들어진 노드로 변경
```

*** 

### [연결리스트 원소의 제거]

```c++
for(int j = 0; j<k; j++)
	cur = cur->next;			//삭제할 원소의 이전원소로 이동

dummy = cur->next;				//dummy에 삭제할 원소를 담는다.
cout << dummy->data;				//삭제할 원소의 data 출력

cur->next = cur->next->next;			//삭제할 원소의 연결 해제
```

### [다른 방식의 연결리스트]  

```c++
const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused=1;

fill(pre, pre+MX, -1);
fill(nxt, nxt+MX, -1);
```  
아래와 같이 저장하면 연결리스트 구현이 가능하다.  

index	|0	|1	|2	|3	|4	|5
--------|-------|-------|-------|-------|-------|------
dat	|-1	|65	|13	|	|21	|17
pre	|-1	|2	|0	|	|1	|4
nxt	|2	|4	|1	|	|5	|-1

# [스택]  

```c++
typedef struct stack
{
	int *data;
	int stack_size;
};
```  
  
또는  
  
```c++
const int MX = 1000005;
int dat[MX];
int pos = 0;

```  

한쪽 끝에서만 원소를 넣거나 뺄 수 있는 자료구조  
먼저 들어간 원소가 가장 나중에 나오는 First In Last Out 구조  

---  

### [스택의 성질]

* 원소 추가의 시간복잡도 O(1)
* 원소 제거의 시간복잡도 O(1)
* 제일 상단의 원소 확인 O(1)
* 제일 상단이 아닌 나머지 원소들의 확인/변경은 원칙적으로 불가능
  
### [스택에 데이터 저장]
```c++
void PushStack(stack* s, int num)
{
	s->data[s->stack_size] = num;
	s->stack_size++;
}
```

### [스택에서 데이터 제거]

```c++
int PopStack(stack* s)
{
	int num = s->data[s->stack_size - 1];
	s->data[s->stack_size - 1] = NULL;
	s->stack_size--;

	return num;
}
```