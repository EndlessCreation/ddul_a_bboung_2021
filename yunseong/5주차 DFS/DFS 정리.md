# DFS : (Depth First Search)  
  
다차원 배열에서 각 칸을 방문할 때 깊이를 우선으로 방문하는 알고리즘  

DFS는 좌표를 담을 스택이 필요하다.  
스택에 나중에 추가된 좌표 근처를 먼저 방문한다.  

```c++
  vis[0][0] = 1; // (0, 0)을 방문했다고 명시
  S.push({0,0}); // 스택에 시작점인 (0, 0)을 삽입.

  while(!S.empty()){

    pair<int,int> cur = S.top();
    S.pop();                          //큐에서 원소를 하나 꺼낸다.

    for(int dir = 0; dir < 4; dir++)  //꺼낸 원소의 상하좌우 칸을 살펴본다.
    { 
      int nx = cur.X + dx[dir];
      int ny = cur.Y + dy[dir];       // nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감

      if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue; // 범위 밖일 경우 Pass
      if(vis[nx][ny] || board[nx][ny] != 1) continue; // 이미 방문한 칸이거나 이동 가능한 칸이 아닐 경우 Pass

      vis[nx][ny] = 1;  // (nx, ny)를 방문했다고 명시
      S.push({nx,ny});  // 스택에 삽입
    }
  }
```  
---

### [해결 과정]  

1. 시작하는 칸을 스택에 넣고 방문했다는 표시를 남긴다.
2. 스택에서 원소를 꺼내어 그 칸과 상하좌우로 인접한 칸에 대해 3번을 진행한다.
3. 해당 칸을 이전에 방문했다면 아무것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 스택에 삽입한다.
4. 스택이 빌 때까지 2번을 반복한다.

모든 칸이 스택에 1번씩 들어가므로 시간복잡도는 칸이 N개일때 O(N)이다.

---



### [BFS vs DFS]

BFS|DFS 
-----------------------|--------------- 
큐를 사용               |스택을 사용 
거리순으로 퍼져가며 방문 |한 방향으로 쭉 방문
거리측정 가능           |거리측정 불가 

BFS와 DFS 모두 최종적인 방문 결과는 같음 