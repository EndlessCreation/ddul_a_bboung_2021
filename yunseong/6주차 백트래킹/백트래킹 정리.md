# 백트래킹  

현재 상태에서 가능한 후보군을 따라 들어가며 선택하는 알고리즘

활용 예시
```c++
void func(int k)
{
    if(k==m)    //총 m개의 수를 모두 골랐을 경우 결과를 출력하고 함수를 종료한다.
    {
        for(int i= 0; i<m; i++)
            cout<<arr[i]<< ' ';
        cout << '\n';
        return;
    }

    for(int i=1; i<=n; i++)
    {
        if(!isused[i])      //사용하지 않은 수를 발견하면
        {
            arr[k] = i;     //i를 arr에 넣고
            isused[i] = 1;  //사용했음을 표시한다.

            func(k+1);      //다음 칸을 채우기 위해 새롭게 func호출
            isused[i] = 0;  //위의 함수가 종료되면 i가 사용중이지 않은 상태로 되돌아 온다.
        }
    }
}
```

---

### [문제 해결 팁]

* 재귀를 사용하여 어떤 상태로 되돌아오는 과정을 이용한다.

* isused[] 의 형태는 다양하게 존재할 수 있다.
```c++
int check_rc[40] = {0, }; //해당 대각선이 이미 점유되었는지 나타내는 배열 r+c값으로 확인
int check_rcn1[40] = {0, }; //해당 대각선이 이미 점유되었는지 나타내는 배열 r-c+n-1로 확인
```

* next_permutation() 을 이용하여 순열을 나타내는 방법
```c++
int a[3] = {1,2,3};
do
{
    for(int i =0; i<3; i++)
        cout << a[i];
    cout<< '\n';
}while(next_permutation(a, a+3));
//next_permutation()은 현재 배열을 다음 사전순으로 재배열하고 true를 반환한다.
//다음 사전순이 없는 경우 false를 반환한다.
```

* next_permutation() 을 이용하여 조합을 나타내는 방법
```c++
//1~4 중 2가지를 골라 출력하려는 경우
int select[4] = {0, 0, 1, 1}; //4개중 2개에서 1을 저장하고 있는 배열을 만든다.
do
{
    for(int i = 0; i< 4; i++)
    {
        if(a[i] == 0)   //1을 저장하고 있는 index+1 값을 출력한다.
            cout<<i+1;
    }
    cout << '\n';
}while(next_permutation(select, select+4));
//next_permutation()은 현재 배열을 다음 사전순으로 재배열하고 true를 반환한다.
//다음 사전순이 없는 경우 false를 반환한다.
```